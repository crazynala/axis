generator client {
    provider = "prisma-client-js"
}

model JobTag {
    id    Int @id @default(autoincrement())
    jobId Int
    tagId Int

    job Job           @relation(fields: [jobId], references: [id], onDelete: Cascade)
    tag TagDefinition @relation(fields: [tagId], references: [id], onDelete: Cascade)

    @@unique([jobId, tagId])
    @@index([tagId])
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model AssemblyTag {
    id         Int @id @default(autoincrement())
    assemblyId Int
    tagId      Int

    assembly Assembly      @relation(fields: [assemblyId], references: [id], onDelete: Cascade)
    tag      TagDefinition @relation(fields: [tagId], references: [id], onDelete: Cascade)

    @@unique([assemblyId, tagId])
    @@index([tagId])
}

enum ColorScheme {
    light
    dark
}

model CostingTag {
    id        Int @id @default(autoincrement())
    costingId Int
    tagId     Int

    costing Costing       @relation(fields: [costingId], references: [id], onDelete: Cascade)
    tag     TagDefinition @relation(fields: [tagId], references: [id], onDelete: Cascade)

    @@unique([costingId, tagId])
    @@index([tagId])
}

enum ProductType {
    CMT
    Fabric
    Finished
    Trim
    Service
}

model ShipmentTag {
    id         Int @id @default(autoincrement())
    shipmentId Int
    tagId      Int

    shipment Shipment      @relation(fields: [shipmentId], references: [id], onDelete: Cascade)
    tag      TagDefinition @relation(fields: [tagId], references: [id], onDelete: Cascade)

    @@unique([shipmentId, tagId])
    @@index([tagId])
}

enum CompanyType {
    vendor
    customer
    other
}

model PurchaseOrderTag {
    id              Int @id @default(autoincrement())
    purchaseOrderId Int
    tagId           Int

    purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
    tag           TagDefinition @relation(fields: [tagId], references: [id], onDelete: Cascade)

    @@unique([purchaseOrderId, tagId])
    @@index([tagId])
}

enum UsageType {
    cut
    make
}

// --- Tagging ---
enum TagScope {
    GLOBAL
    USER
}

model TagDefinition {
    id        Int      @id @default(autoincrement())
    name      String
    scope     TagScope
    ownerId   Int?
    color     String?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    owner User? @relation(fields: [ownerId], references: [id])

    // joins
    productTags       ProductTag[]
    jobTags           JobTag[]
    assemblyTags      AssemblyTag[]
    costingTags       CostingTag[]
    shipmentTags      ShipmentTag[]
    purchaseOrderTags PurchaseOrderTag[]

    @@unique([name, scope, ownerId])
}

model Product {
    id                   Int                   @id @default(autoincrement())
    sku                  String?               @unique
    name                 String?
    description          String?
    type                 ProductType?
    supplierId           Int?
    customerId           Int?
    costPrice            Decimal?              @db.Decimal(14, 4)
    costCurrency         String?               @default("USD")
    purchaseTaxId        Int?
    categoryId           Int?
    subCategory          String?
    pricingGroupId       Int?
    manualSalePrice      Decimal?              @db.Decimal(14, 4)
    // Optional per-item manual margin (mutually exclusive with manualSalePrice; enforce in app logic)
    manualMargin         Decimal?              @db.Decimal(14, 4)
    defaultCostQty       Int                   @default(60)
    variantSetId         Int?
    stockTrackingEnabled Boolean               @default(false)
    batchTrackingEnabled Boolean               @default(false)
    isActive             Boolean?
    notes                String?
    supplier             Company?              @relation("Supplier", fields: [supplierId], references: [id])
    customer             Company?              @relation("Customer", fields: [customerId], references: [id])
    purchaseTax          ValueList?            @relation("Tax", fields: [purchaseTaxId], references: [id])
    category             ValueList?            @relation("Category", fields: [categoryId], references: [id])
    pricingGroup         SupplierPricingGroup? @relation(fields: [pricingGroupId], references: [id])
    // Optional direct link to a Product Cost Group for pricing defaults
    costGroupId          Int?
    costGroup            ProductCostGroup?     @relation(fields: [costGroupId], references: [id])
    // Optional link to a Sale Price Group for sale tiers
    salePriceGroupId     Int?
    salePriceGroup       SalePriceGroup?       @relation(fields: [salePriceGroupId], references: [id])
    variantSet           VariantSet?           @relation(fields: [variantSetId], references: [id])
    productLines         ProductLine[]         @relation("ParentProduct")
    batches              Batch[]
    productMovements     ProductMovementLine[]
    Costing              Costing[]
    ProductLine          ProductLine[]
    // Removed: Variant back-relation; Variant model dropped
    // Back-relations
    invoiceLines         InvoiceLine[]
    shipmentLines        ShipmentLine[]
    expenses             Expense[]
    // Back-relations: Purchase Orders
    purchaseOrderLines   PurchaseOrderLine[]
    // Back-relations: Tags
    productTags          ProductTag[]
    // Back-relations: Cost ranges (per-product tiered costs)
    productCostRanges    ProductCostRange[]
    salePriceRanges      SalePriceRange[]
    // Removed: back-relations to assemblies and activities to decouple history
    // Optional inverse for assemblies' primary product relation
    // primaryAssemblies     Assembly[]            @relation("AssemblyPrimaryProduct")
    // Metadata
    createdBy            String?
    modifiedBy           String?
    createdAt            DateTime?             @default(now())
    updatedAt            DateTime?             @updatedAt
}

// Join tables for tags
model ProductTag {
    id        Int      @id @default(autoincrement())
    productId Int
    tagId     Int
    createdAt DateTime @default(now())

    product Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
    tag     TagDefinition @relation(fields: [tagId], references: [id], onDelete: Cascade)

    @@unique([productId, tagId])
    @@index([tagId])
}

model Company {
    id                              Int                     @id @default(autoincrement())
    name                            String?
    address                         String?
    city                            String?
    state                           String?
    zip                             String?
    country                         String?
    phone                           String?
    email                           String?
    website                         String?
    notes                           String?
    // isActive                  Boolean?
    isCarrier                       Boolean?
    isCustomer                      Boolean?
    isSupplier                      Boolean?
    isInactive                      Boolean?
    // Optional default margin override for this vendor (used when computing sale prices)
    defaultMarginOverride           Decimal?                @db.Decimal(14, 4)
    // Optional default sale price multiplier for this customer (applies to sale tiers)
    priceMultiplier                 Decimal?                @db.Decimal(14, 4)
    productsSupplied                Product[]               @relation("Supplier")
    productsPurchased               Product[]               @relation("Customer")
    pricingGroups                   SupplierPricingGroup[]
    jobs                            Job[]
    // Back-relations
    invoices                        Invoice[]
    addresses                       Address[]
    shipmentsAsCarrier              Shipment[]              @relation("CarrierCompany")
    shipmentsAsReceiver             Shipment[]              @relation("ReceiverCompany")
    shipmentsAsSender               Shipment[]              @relation("SenderCompany")
    contacts                        Contact[]
    // Back-relations: Purchase Orders
    purchaseOrders                  PurchaseOrder[]
    purchaseOrdersAsConsignee       PurchaseOrder[]         @relation("POConsignee")
    // Back-relations: Product Cost Groups
    productCostGroups               ProductCostGroup[]
    // Back-relations: Vendor/Customer pricing mappings
    vendorCustomerPricingAsVendor   VendorCustomerPricing[] @relation("VendorCompany")
    vendorCustomerPricingAsCustomer VendorCustomerPricing[] @relation("CustomerCompany")
    // Metadata
    createdBy                       String?
    modifiedBy                      String?
    createdAt                       DateTime?               @default(now())
    updatedAt                       DateTime?               @updatedAt
}

model VariantSet {
    id            Int            @id @default(autoincrement())
    name          String?
    variants      String[]
    products      Product[]
    assemblies    Assembly[]
    // Back-relations
    shipmentLines ShipmentLine[]
    // Metadata
    createdBy     String?
    modifiedBy    String?
    createdAt     DateTime?      @default(now())
    updatedAt     DateTime?      @updatedAt
}

model SupplierPricingGroup {
    id         Int       @id @default(autoincrement())
    name       String?
    supplierId Int?
    products   Product[]
    supplier   Company?  @relation(fields: [supplierId], references: [id])
    // Metadata
    createdBy  String?
    modifiedBy String?
    createdAt  DateTime? @default(now())
    updatedAt  DateTime? @updatedAt
}

model ValueList {
    id                  Int           @id @default(autoincrement())
    code                String?
    label               String?
    value               Decimal?      @db.Decimal(14, 4)
    type                String?
    productsTax         Product[]     @relation("Tax")
    productsCategory    Product[]     @relation("Category")
    // Back-relations
    invoiceLinesTaxCode InvoiceLine[] @relation("TaxCode")
    invoicesTaxCode     Invoice[]     @relation("Inv_TaxCode")
    // Back-relations: Purchase Orders
    // Removed: PurchaseOrderLine taxCode relation; POL now stores taxCode as string
    // Metadata
    createdBy           String?
    modifiedBy          String?
    createdAt           DateTime?     @default(now())
    updatedAt           DateTime?     @updatedAt
}

model Assembly {
    id                  Int                 @id @default(autoincrement())
    name                String?
    status              String?
    quantity            Decimal?            @db.Decimal(14, 4)
    // Breakdown of ordered quantities (e.g., sizes): [0,0,11,12,7,1,0]
    qtyOrderedBreakdown Int[]               @default([])
    notes               String?
    // Removed: per-assembly Variant linkage; Variant model dropped
    // Removed direct Batch relation; batches are independent of assemblies
    job                 Job?                @relation(fields: [jobId], references: [id], name: "Job_Assemblies")
    jobId               Int?
    // Optional grouping of assemblies within a job
    assemblyGroupId     Int?
    assemblyGroup       AssemblyGroup?      @relation(fields: [assemblyGroupId], references: [id])
    // Link Assembly to original Product by id only (no relation)
    productId           Int?
    // Optional link to a Variant Set (may mirror the Product's variant set)
    variantSetId        Int?
    variantSet          VariantSet?         @relation(fields: [variantSetId], references: [id])
    activities          AssemblyActivity[]  @relation("Assembly_Activities")
    costings            Costing[]
    batches             Batch[]
    // Back-relations
    shipmentLines       ShipmentLine[]
    // Back-relations: Purchase Order Lines referencing this assembly
    purchaseOrderLines  PurchaseOrderLine[]
    // Back-relations: Tags
    assemblyTags        AssemblyTag[]
    // Metadata
    createdBy           String?
    modifiedBy          String?
    createdAt           DateTime?           @default(now())
    updatedAt           DateTime?           @updatedAt
}

model Costing {
    id                            Int             @id @default(autoincrement())
    assemblyId                    Int?
    // renamed: componentId -> productId; removed usageType/componentType per new spec
    productId                     Int?
    quantityPerUnit               Decimal?        @db.Decimal(14, 4)
    unitCost                      Decimal?        @db.Decimal(14, 4)
    notes                         String?
    activityUsed                  String?
    costPricePerItem              Decimal?        @db.Decimal(14, 4)
    salePricePerItem              Decimal?        @db.Decimal(14, 4)
    // Dynamic pricing context pulled from Product to compute sale prices prior to fixing
    // Optional link to a Sale Price Group for tiered sale pricing at the time of costing
    salePriceGroupId              Int?
    salePriceGroup                SalePriceGroup? @relation("Costing_SalePriceGroup", fields: [salePriceGroupId], references: [id])
    // Optional manual overrides captured on the costing
    manualSalePrice               Decimal?        @db.Decimal(14, 4)
    manualMargin                  Decimal?        @db.Decimal(14, 4)
    flagAssembly                  Boolean?
    flagDefinedInProduct          Boolean?
    flagIsBillableDefaultOrManual Boolean?
    flagIsBillableManual          Boolean?
    flagIsInvoiceableManual       Boolean?
    flagStockTracked              Boolean?
    assembly                      Assembly?       @relation(fields: [assemblyId], references: [id])
    product                       Product?        @relation(fields: [productId], references: [id])
    // Metadata
    createdBy                     String?
    modifiedBy                    String?
    createdAt                     DateTime?       @default(now())
    updatedAt                     DateTime?       @updatedAt
    // Back-relations
    invoiceLines                  InvoiceLine[]
    // Back-relations: Tags
    costingTags                   CostingTag[]
}

model ProductLine {
    id               Int       @id @default(autoincrement())
    parentId         Int?
    childId          Int?
    quantity         Decimal?  @db.Decimal(14, 4)
    unitCost         Decimal?  @db.Decimal(14, 4)
    unitCostManual   Decimal?  @db.Decimal(14, 4)
    activityUsed     String?
    flagAssemblyOmit Boolean?
    parent           Product?  @relation("ParentProduct", fields: [parentId], references: [id])
    child            Product?  @relation(fields: [childId], references: [id])
    // Metadata
    createdBy        String?
    modifiedBy       String?
    createdAt        DateTime? @default(now())
    updatedAt        DateTime? @updatedAt
}

model Location {
    id                    Int                @id @default(autoincrement())
    name                  String?
    type                  String?
    is_active             Boolean?
    notes                 String?
    batches               Batch[]
    ProductMovement       ProductMovement[]
    jobsIn                Job[]              @relation("Job_LocationIn")
    jobsOut               Job[]              @relation("Job_LocationOut")
    assemblyActivitiesIn  AssemblyActivity[] @relation("AssemblyActivity_LocationIn")
    assemblyActivitiesOut AssemblyActivity[] @relation("AssemblyActivity_LocationOut")
    // Back-relations
    shipments             Shipment[]
    shipmentLines         ShipmentLine[]
    // Back-relations: Purchase Orders
    purchaseOrders        PurchaseOrder[]
    // Metadata
    createdBy             String?
    modifiedBy            String?
    createdAt             DateTime?          @default(now())
    updatedAt             DateTime?          @updatedAt
}

model Batch {
    id                  Int                   @id @default(autoincrement())
    productId           Int?
    locationId          Int?
    jobId               Int?
    assemblyId          Int?
    codeMill            String?
    codeSartor          String?
    name                String?
    source              String?
    quantity            Decimal?              @db.Decimal(14, 4)
    receivedAt          DateTime?
    notes               String?
    product             Product?              @relation(fields: [productId], references: [id])
    location            Location?             @relation(fields: [locationId], references: [id])
    job                 Job?                  @relation(fields: [jobId], references: [id])
    assembly            Assembly?             @relation(fields: [assemblyId], references: [id])
    ProductMovementLine ProductMovementLine[]
    // Removed: Variant link; Variant model dropped
    // Metadata
    createdBy           String?
    modifiedBy          String?
    createdAt           DateTime?             @default(now())
    updatedAt           DateTime?             @updatedAt
}

model ProductMovement {
    id                  Int                   @id @default(autoincrement())
    movementType        String?
    date                DateTime?
    locationId          Int?
    // New mapped fields (scalars for import mapping)
    assemblyActivityId  Int?
    assemblyId          Int?
    // Support group-level recording of movements
    assemblyGroupId     Int?
    costingId           Int?
    expenseId           Int?
    jobId               Int?
    locationInId        Int?
    locationOutId       Int?
    shippingType        String?
    // Optional linkage key for grouping activities/movements
    groupKey            String?
    productId           Int?
    quantity            Decimal?              @db.Decimal(14, 4)
    purchaseOrderLineId Int?
    shippingLineId      Int?
    notes               String?
    lines               ProductMovementLine[]
    location            Location?             @relation(fields: [locationId], references: [id])
    // Metadata
    createdBy           String?
    modifiedBy          String?
    createdAt           DateTime?             @default(now())
    updatedAt           DateTime?             @updatedAt

    @@index([productId], map: "idx_product_movement_product_id")
    // Composite index to support ordered scans/filtering by product then date
    @@index([productId, date, id], map: "idx_product_movement_product_date_id")
}

model ProductMovementLine {
    id                  Int              @id @default(autoincrement())
    movementId          Int?
    productId           Int?
    batchId             Int?
    costingId           Int?
    productMovementId   Int?
    purchaseOrderLineId Int?
    quantity            Decimal?         @db.Decimal(14, 4)
    notes               String?
    movement            ProductMovement? @relation(fields: [movementId], references: [id])
    product             Product?         @relation(fields: [productId], references: [id])
    batch               Batch?           @relation(fields: [batchId], references: [id])
    // Metadata
    createdBy           String?
    modifiedBy          String?
    createdAt           DateTime?        @default(now())
    updatedAt           DateTime?        @updatedAt

    @@index([productId], map: "idx_product_movement_line_product_id")
}

model Job {
    id                      Int                 @id @default(autoincrement())
    projectCode             String?
    name                    String?
    description             String?
    startDate               DateTime?
    endDate                 DateTime?
    status                  String?
    jobType                 String?
    isActive                Boolean?
    notes                   String?
    endCustomerName         String?
    companyId               Int?
    company                 Company?            @relation(fields: [companyId], references: [id])
    locationInId            Int?
    locationOutId           Int?
    locationIn              Location?           @relation("Job_LocationIn", fields: [locationInId], references: [id])
    locationOut             Location?           @relation("Job_LocationOut", fields: [locationOutId], references: [id])
    customerOrderDate       DateTime?
    customerOrderDateManual DateTime?
    cutSubmissionDate       DateTime?
    dropDeadDate            DateTime?
    finishDate              DateTime?
    finishDateManual        DateTime?
    firstInvoiceDate        DateTime?
    targetDate              DateTime?
    customerPoNum           String?
    // Removed: Variant back-relation; Variant model dropped
    assemblyActivities      AssemblyActivity[]
    assemblies              Assembly[]          @relation("Job_Assemblies")
    // Back-relations: Assembly groups within this job
    assemblyGroups          AssemblyGroup[]
    batches                 Batch[]
    // Back-relations
    invoiceLines            InvoiceLine[]
    shipmentLines           ShipmentLine[]
    expenses                Expense[]
    // Back-relations: Purchase Orders
    purchaseOrderLines      PurchaseOrderLine[]
    // Back-relations: Tags
    jobTags                 JobTag[]
    // Metadata
    createdBy               String?
    modifiedBy              String?
    createdAt               DateTime?           @default(now())
    updatedAt               DateTime?           @updatedAt
}

// Group multiple assemblies within a job (for planning/visual grouping)
model AssemblyGroup {
    id         Int        @id @default(autoincrement())
    jobId      Int?
    name       String?
    job        Job?       @relation(fields: [jobId], references: [id])
    assemblies Assembly[]
    // Metadata
    createdBy  String?
    modifiedBy String?
    createdAt  DateTime?  @default(now())
    updatedAt  DateTime?  @updatedAt
}

model SavedView {
    id         Int      @id @default(autoincrement())
    module     String
    name       String
    params     Json
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt
    createdBy  String?
    modifiedBy String?
}

model AssemblyActivity {
    id                       Int       @id @default(autoincrement())
    assemblyId               Int?
    jobId                    Int?
    name                     String?
    description              String?
    activityType             String?
    activityDate             DateTime?
    // Optional key to link activities performed together across multiple assemblies
    groupKey                 String?
    // Removed: deprecated time/status fields per new spec
    notes                    String?
    productId                Int?
    locationInId             Int?
    locationOutId            Int?
    locationIn               Location? @relation("AssemblyActivity_LocationIn", fields: [locationInId], references: [id])
    locationOut              Location? @relation("AssemblyActivity_LocationOut", fields: [locationOutId], references: [id])
    quantity                 Decimal?  @db.Decimal(14, 4)
    qtyFabricConsumed        Decimal?  @db.Decimal(14, 4)
    qtyFabricConsumedPerUnit Decimal?  @db.Decimal(14, 4)
    qtyBreakdown             Int[]     @default([])
    assembly                 Assembly? @relation(fields: [assemblyId], references: [id], name: "Assembly_Activities")
    job                      Job?      @relation(fields: [jobId], references: [id])
    // Metadata
    createdBy                String?
    modifiedBy               String?
    createdAt                DateTime? @default(now())
    updatedAt                DateTime? @updatedAt
}

// --- Auth models ---
model User {
    id               Int             @id @default(autoincrement())
    email            String          @unique
    passwordHash     String
    name             String?
    recordsPerPage   Int             @default(25)
    isActive         Boolean         @default(true)
    colorScheme      ColorScheme     @default(light)
    // Persist UI preference for desktop sidebar open/closed
    desktopNavOpened Boolean         @default(true)
    createdAt        DateTime        @default(now())
    updatedAt        DateTime        @updatedAt
    resets           PasswordReset[]
    // Back-relations: Tag owner
    tagDefinitions   TagDefinition[]
}

model PasswordReset {
    id        Int       @id @default(autoincrement())
    userId    Int
    user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    otp       String
    token     String    @unique
    expiresAt DateTime
    usedAt    DateTime?
    createdAt DateTime  @default(now())
}

// --- New data models from FileMaker imports ---

model DHLReportLine {
    id                         Int       @id // a__Serial maps here
    accountName                String?
    awbNumber                  String?
    billedWeight               Decimal?  @db.Decimal(14, 4)
    billingAccountNumber       String?
    billingExchangeRate        Decimal?  @db.Decimal(14, 4)
    destinationCountryCode     String?
    destinationCountryName     String?
    destinationServiceAreaCode String?
    destinationServiceAreaName String?
    globalProductCode          String?
    globalProductName          String?
    invoiceDate                DateTime?
    invoiceNumber              String?
    numberOfPieces             Int?
    opsConsigneeContactName    String?
    opsConsigneeName           String?
    opsConsignorContactName    String?
    opsConsignorName           String?
    originCountryCode          String?
    originCountryName          String?
    originServiceAreaCode      String?
    originServiceAreaName      String?
    relativePeriod             String?
    shipmentPickUpDate         DateTime?
    shipmentReference          String?
    shipperAccountNumber       String?
    totalRevenueEUR            Decimal?  @db.Decimal(14, 4)
    totalRevenueLCY            Decimal?  @db.Decimal(14, 4)
    totalTaxEUR                Decimal?  @db.Decimal(14, 4)
    totalTaxLCY                Decimal?  @db.Decimal(14, 4)
    createdAt                  DateTime? @default(now())
    updatedAt                  DateTime? @updatedAt
}

model ForexLine {
    id           Int      @id @default(autoincrement())
    date         DateTime
    price        Float
    currencyFrom String   @default("USD")
    currencyTo   String   @default("TRY")
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    @@unique([date, currencyFrom, currencyTo])
}

model Invoice {
    id              Int           @id // a__Serial maps here
    companyId       Int?
    invoiceCode     String?       @unique
    date            DateTime?
    // Additional imported fields
    productSkuCopy  String?
    productNameCopy String?
    priceCost       Decimal?      @db.Decimal(14, 4)
    priceSell       Decimal?      @db.Decimal(14, 4)
    taxCodeId       Int?
    taxRateCopy     Decimal?      @db.Decimal(14, 4)
    notes           String?
    status          String?
    createdBy       String?
    createdAt       DateTime?     @default(now())
    modifiedBy      String?
    updatedAt       DateTime?     @updatedAt
    company         Company?      @relation(fields: [companyId], references: [id])
    taxCode         ValueList?    @relation("Inv_TaxCode", fields: [taxCodeId], references: [id])
    lines           InvoiceLine[]
}

model InvoiceLine {
    id                  Int        @id // a__Serial maps here
    costingId           Int?
    expenseId           Int?
    invoiceId           Int?
    jobId               Int?
    productId           Int?
    purchaseOrderLineId Int?
    shippingIdActual    Int?
    shippingIdDuty      Int?
    category            String?
    details             String?
    subCategory         String?
    priceCost           Decimal?   @db.Decimal(14, 4)
    priceSell           Decimal?   @db.Decimal(14, 4)
    quantity            Decimal?   @db.Decimal(14, 4)
    taxCodeId           Int?
    // Renamed to reflect source import naming
    taxRateCopy         Decimal?   @db.Decimal(14, 4)
    invoicedTotalManual Decimal?   @db.Decimal(14, 4)
    createdBy           String?
    createdAt           DateTime?  @default(now())
    modifiedBy          String?
    updatedAt           DateTime?  @updatedAt
    invoice             Invoice?   @relation(fields: [invoiceId], references: [id])
    costing             Costing?   @relation(fields: [costingId], references: [id])
    expense             Expense?   @relation(fields: [expenseId], references: [id])
    job                 Job?       @relation(fields: [jobId], references: [id])
    product             Product?   @relation(fields: [productId], references: [id])
    taxCode             ValueList? @relation("TaxCode", fields: [taxCodeId], references: [id])
}

model Expense {
    id              Int           @id // a__Serial maps here
    jobId           Int?
    productId       Int?
    purchaseOrderId Int?
    shippingId      Int?
    category        String?
    date            DateTime?
    details         String?
    memo            String?
    priceCost       Decimal?      @db.Decimal(14, 4)
    priceSell       Decimal?      @db.Decimal(14, 4)
    quantity        Decimal?      @db.Decimal(14, 4)
    source          String?
    subcategory     String?
    createdBy       String?
    createdAt       DateTime?     @default(now())
    modifiedBy      String?
    updatedAt       DateTime?     @updatedAt
    job             Job?          @relation(fields: [jobId], references: [id])
    product         Product?      @relation(fields: [productId], references: [id])
    shipment        Shipment?     @relation(fields: [shippingId], references: [id])
    // Back-relations
    invoiceLines    InvoiceLine[]
}

model Shipment {
    id                 Int            @id // a__Serial maps here
    addressIdShip      Int?
    companyIdCarrier   Int?
    companyIdReceiver  Int?
    companyIdSender    Int?
    locationId         Int?
    contactIdReceiver  Int?
    date               DateTime?
    dateReceived       DateTime?
    packingSlipCode    String?
    shipmentType       String?
    status             String?
    trackingNo         String?
    type               String? // "In" | "Out"
    memo               String?
    shippingMethod     String?
    addressName        String?
    addressCountry     String?
    addressCountyState String?
    addressLine1       String?
    addressLine2       String?
    addressLine3       String?
    addressTownCity    String?
    addressZipPostCode String?
    createdBy          String?
    createdAt          DateTime?      @default(now())
    modifiedBy         String?
    updatedAt          DateTime?      @updatedAt
    location           Location?      @relation(fields: [locationId], references: [id])
    companyCarrier     Company?       @relation("CarrierCompany", fields: [companyIdCarrier], references: [id])
    companyReceiver    Company?       @relation("ReceiverCompany", fields: [companyIdReceiver], references: [id])
    companySender      Company?       @relation("SenderCompany", fields: [companyIdSender], references: [id])
    addressShip        Address?       @relation("Address_shipments", fields: [addressIdShip], references: [id])
    lines              ShipmentLine[]
    // Back-relations
    expenses           Expense[]
    // Back-relations: Tags
    shipmentTags       ShipmentTag[]
}

model ShipmentLine {
    id           Int         @id // a__Serial maps here
    assemblyId   Int?
    jobId        Int?
    locationId   Int?
    productId    Int?
    // Renamed from shippingId -> shipmentId
    shipmentId   Int?
    variantSetId Int?
    category     String?
    details      String?
    quantity     Decimal?    @db.Decimal(14, 4)
    qtyBreakdown Int[]       @default([]) // parsed from Qty_Breakdown_List_c
    status       String?
    subCategory  String?
    createdBy    String?
    createdAt    DateTime?   @default(now())
    modifiedBy   String?
    updatedAt    DateTime?   @updatedAt
    assembly     Assembly?   @relation(fields: [assemblyId], references: [id])
    job          Job?        @relation(fields: [jobId], references: [id])
    location     Location?   @relation(fields: [locationId], references: [id])
    product      Product?    @relation(fields: [productId], references: [id])
    shipment     Shipment?   @relation(fields: [shipmentId], references: [id])
    variantSet   VariantSet? @relation(fields: [variantSetId], references: [id])
}

model Address {
    id                 Int        @id // a__Serial maps here
    companyId          Int?
    contactId          Int?
    name               String?
    addressCountry     String?
    addressCountyState String?
    addressLine1       String?
    addressLine2       String?
    addressLine3       String?
    addressTownCity    String?
    addressZipPostCode String?
    createdBy          String?
    createdAt          DateTime?  @default(now())
    modifiedBy         String?
    updatedAt          DateTime?  @updatedAt
    company            Company?   @relation(fields: [companyId], references: [id])
    shipments          Shipment[] @relation("Address_shipments")
    contacts           Contact[]
}

// --- Contacts ---
model Contact {
    id          Int       @id // a__Serial maps here
    addressId   Int?
    companyId   Int?
    email       String?
    department  String?
    firstName   String?
    lastName    String?
    title       String?
    phoneDirect String?
    phoneHome   String?
    phoneMobile String?
    position    String?
    recordType  String? // Employee | Contact | Customer
    createdBy   String?
    createdAt   DateTime? @default(now())
    modifiedBy  String?
    updatedAt   DateTime? @updatedAt
    address     Address?  @relation(fields: [addressId], references: [id])
    company     Company?  @relation(fields: [companyId], references: [id])
}

// --- Purchase Orders ---

model PurchaseOrder {
    id                 Int                 @id // a__Serial maps here
    companyId          Int?
    consigneeCompanyId Int?
    locationId         Int?
    date               DateTime?
    memo               String?
    status             String?
    createdBy          String?
    createdAt          DateTime?           @default(now())
    modifiedBy         String?
    updatedAt          DateTime?           @updatedAt
    company            Company?            @relation(fields: [companyId], references: [id])
    consignee          Company?            @relation("POConsignee", fields: [consigneeCompanyId], references: [id])
    location           Location?           @relation(fields: [locationId], references: [id])
    lines              PurchaseOrderLine[]
    // Back-relations: Tags
    purchaseOrderTags  PurchaseOrderTag[]
}

model PurchaseOrderLine {
    id              Int            @id // a__Serial maps here
    purchaseOrderId Int?
    jobId           Int?
    // Optional link to assembly (for import mapping a_AssemblyID)
    assemblyId      Int?
    productId       Int?
    productSkuCopy  String?
    productNameCopy String?
    priceCost       Decimal?       @db.Decimal(14, 4)
    priceSell       Decimal?       @db.Decimal(14, 4)
    qtyShipped      Decimal?       @db.Decimal(14, 4)
    qtyReceived     Decimal?       @db.Decimal(14, 4)
    quantity        Decimal?       @db.Decimal(14, 4)
    quantityOrdered Decimal?       @db.Decimal(14, 4)
    taxCode         String?
    taxRate         Decimal?       @db.Decimal(14, 4)
    createdBy       String?
    createdAt       DateTime?      @default(now())
    modifiedBy      String?
    updatedAt       DateTime?      @updatedAt
    purchaseOrder   PurchaseOrder? @relation(fields: [purchaseOrderId], references: [id])
    job             Job?           @relation(fields: [jobId], references: [id])
    assembly        Assembly?      @relation(fields: [assemblyId], references: [id])
    product         Product?       @relation(fields: [productId], references: [id])
    // Removed: relation to ValueList for tax code; use string taxCode and map via (type, code) when needed
}

// --- Product Cost Pricing ---

model ProductCostGroup {
    id              Int                @id @default(autoincrement())
    supplierId      Int?
    currency        String?
    name            String?
    costPrice       Decimal?           @db.Decimal(14, 4)
    sellPriceManual Decimal?           @db.Decimal(14, 4)
    supplier        Company?           @relation(fields: [supplierId], references: [id])
    // Back-relations: Cost ranges belonging to this group
    costRanges      ProductCostRange[]
    // Back-relations: Products directly assigned to this group
    products        Product[]
    // Metadata
    createdBy       String?
    modifiedBy      String?
    createdAt       DateTime?          @default(now())
    updatedAt       DateTime?          @updatedAt

    @@index([supplierId])
}

model ProductCostRange {
    id              Int               @id @default(autoincrement())
    productId       Int?
    costGroupId     Int?
    costPrice       Decimal?          @db.Decimal(14, 4)
    sellPriceManual Decimal?          @db.Decimal(14, 4)
    rangeFrom       Int?
    rangeTo         Int?
    product         Product?          @relation(fields: [productId], references: [id])
    costGroup       ProductCostGroup? @relation(fields: [costGroupId], references: [id])
    // Metadata
    createdBy       String?
    modifiedBy      String?
    createdAt       DateTime?         @default(now())
    updatedAt       DateTime?         @updatedAt

    // Note: Exactly one of productId or costGroupId should be set; invariant enforced in application/import logic
    @@index([productId])
    @@index([costGroupId])
}

// --- Sale Price Groups (explicit sale tiers separate from cost groups) ---

model SalePriceGroup {
    id         Int              @id @default(autoincrement())
    name       String?
    currency   String?
    // Back-relations: Products directly assigned to this sale group
    products   Product[]
    // Back-relations: Ranges belonging to this group
    saleRanges SalePriceRange[]
    // Back-relations: Costings referencing this sale group at time of pricing
    costings   Costing[]        @relation("Costing_SalePriceGroup")
    // Metadata
    createdBy  String?
    modifiedBy String?
    createdAt  DateTime?        @default(now())
    updatedAt  DateTime?        @updatedAt
}

model SalePriceRange {
    id          Int             @id @default(autoincrement())
    productId   Int?
    saleGroupId Int?
    // Sale price for this tier (pre-tax, in group currency)
    price       Decimal?        @db.Decimal(14, 4)
    rangeFrom   Int?
    rangeTo     Int?
    product     Product?        @relation(fields: [productId], references: [id])
    saleGroup   SalePriceGroup? @relation(fields: [saleGroupId], references: [id])
    // Metadata
    createdBy   String?
    modifiedBy  String?
    createdAt   DateTime?       @default(now())
    updatedAt   DateTime?       @updatedAt

    // Exactly one of productId or saleGroupId should be set; enforce in application logic
    @@index([productId])
    @@index([saleGroupId])
}

// --- Pricing overrides & settings ---

// Pair-specific pricing between a vendor (supplier) and a customer
model VendorCustomerPricing {
    id             Int      @id @default(autoincrement())
    vendorId       Int
    customerId     Int
    // Optional override margin to use instead of defaults when computing sale price
    marginOverride Decimal? @db.Decimal(14, 4)
    // Metadata
    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    vendor   Company @relation("VendorCompany", fields: [vendorId], references: [id], onDelete: Cascade)
    customer Company @relation("CustomerCompany", fields: [customerId], references: [id], onDelete: Cascade)

    @@unique([vendorId, customerId])
    @@index([customerId])
}

// Simple application-wide settings registry
model Setting {
    key       String   @id
    value     String?
    number    Decimal? @db.Decimal(14, 4)
    json      Json?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}
